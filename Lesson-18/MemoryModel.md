
## Memory model
### Виклики багатопоточності
- Синхронізація пам'яті між потоками
- Race Condition
- Оптимізація компілятора і процесора
### What is Memory model
- Які інструкції можна оптимізувати а які нє (все має виконуватися в правильному порядку)
- Як саме потокам обмінюватися даними (один потік бачить актуальне значення)
- Якось запобігти Race Condition-у

Просто набір правил

### Основні поняття
- Data Race - Конфлікт під час одночасної зміни/читання змінної двома+ потоками. => Undefined behavior (UB)
- UB - Компілятор не гарантує нічого
- Атомарність (std::atomic). Неділимість операції. Або виконана повністю або навіть не почата. 
- Порядок виконання
- Синхронізація пам'яті. "сповіщення" одним потоком іншого, що значення було змінене. Інакше значення лишеться таке як в кеші другого потоку і ніхто ні про шо не дізнається. (relaxing, acquire, release, sequential consistency).

-----
## std::atomic
Це тип, гарантує, що всі операції будуть атомарними.

- load(), store(). load - безпечне читання. store - безпечний запис. Є гарантії того, що інші потоки побачать зміни через load.
- fetch_add(), fetch_sub(). Операції read-modify-write. fetch_add(n) додає до атоміка n і повертає попереднє значення змінної. fetch_sub(n) - зменшення аналогічно.
- compare_exchange_weak, compare_exchange_strong - операції порівняння і обміну. CAS(Compare-and-Switch)

---
## Memory Ordering

Основні режими:
- memory_order_relaxed: тільки атомарність. На порядок виконання йому все одно
- memory_order_acquire, memory_order_release: release для запису даних, acquire для читання даних. Працюють в парі
- memory_order_seq_cst: послідовна узгодженість. НАЙСТРОГІШИЙ

1. Memory Relaxed:
- Найменш строгий. Операції в довільному порядку
- Гарантує атомарність
2. memory_order_acquire, memory_order_release
- memory_order_release: Для запису. 
3. memory_order_seq_cst
- Гарантує що все буде строго послідовно
